<!DOCTYPE html>
<html>

<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="mystyles.css">

	
<style>
  .mySlides {display:none;}
</style>
<!--<body style="background-color:#FFFFFF;margin-left:50px;">-->
	<body style="background-color:#FFFFFF;">
</head>

<body style="background-color:#FFFFFF;">
<div class="content-wrapper">
  <!-- All your content goes here -->


<div class="banner-container">
<img src="WebBanner2023.png" alt="Banner" class="banner">
</div>

<!--<img src="WebBanner2023.png" alt="Banner" class="banner">-->

<h1>ENG0018 Computer Labs 2025/26</h1>
<h2>Student URN: 6929344</h2>
	
<hr>
  <h2 style="font-family:calibri:"><b>Conference paper: To what extent is parallel processing the most useful method for Particle-in-cell Simulations?</b></h2>
<hr>

<style>
  table {
    font-family: Calibri (body);
    border-collapse: collapse;
    width: 30%;
  }

  td, th {
    border: 1px solid #dddddd;
    text-align: left;
    padding: 8px;
  }

  tr:nth-child(even) {
    background-color: #dddddd;
  }
</style>




<!--contents-->
<hr>
<table id="contents">
<tr>
<th><h3>Table of contents</h3></th>
  </tr>
  <tr><td><a href="#Abstract">Abstract</a></td></tr>
  <tr><td><a href="#Video">Video</a></td></tr>
  <tr><td><a href="#Introduction">Introduction</a></td></tr>
  <tr><td><a href="#Analysis">Analysis</a></td></tr>
  <tr><td><a href="#References">References</a></td></tr>
</table>
</hr>

	
<!--Abstract-->
<hr>
<h4 id="Abstract">Abstract</h4>
<p>
Particle-in-cell simulations are needed in order to be able to model specific problems in science so they can be understood, for example modelling plasma to understand how to control it in fusion reactors. Parallel processing is used because it is able to process complex equations in relatively quick speeds. This was determined by using a simple binary search to compare sequential vs parallel processing methods, where various sizes of data sets were searched in order to find the average time taken to complete each stage of the search. Another finding was that costs of hardware, software and energy consumption requirements were cheaper for parallel processing compared to a quantum parallelism method, meaning that it would be more accessible to the average researcher. With this evidence, it was gathered that parallel processing would be the most suitable method for particle-in-cell simulations.
</p>
  
<!--Video-->
<hr>
<h4 id="Video">Watch the video:</h4>
<video src="PIC-powerpoint.mp4" width="800" height="450" controls>
</video>
</hr>

	
<!--Introduction-->
<hr>
<h4 id="Introduction">Introduction</h4>
<p>
Across all disciplines of science parallel processing plays an important role in being able to solve complex problems in high speeds. In modern physics, it can be used to model black holes by running extremely complex equations simultaneously, allowing scientists to see the effects of the model in real time. In doing so, scientists are able to test theories like Einstein's general relativity without having to actually perform experiments that are not yet possible. In other areas of physics, Particle-in-cell (PIC) simulations can be used to solve problems too. For example, being able to determine how to control high temperature plasma in nuclear fusion reactors in order to keep experiments safe. Firstly, what PIC simulations are and why are they needed will be discussed, followed by what parallel processing actually is and how it compares to other methods, which will then all be summarised in a conclusion.
</p>
</hr>

  
<!--Analysis-->
<hr>
<h4 id="Analysis">Analysis</h4>
<p>
<strong>What are PIC simulations and why are they important?</strong> <br>
PIC simulations "are routinely used as effective tools to understand kinetic phenomena in laboratory, astrophysical and fusion-relevant plasmas" <a href="https://doi-org.surrey.idm.oclc.org/10.1016/j.jcp.2019.03.020">(Higginson et al., 2019)</a>, which is important as this allows scientists to understand how to control high temperature plasmas in nuclear fusion reactors. The need to control these plasmas is so they do not "damage the reactor and cause the plasma to cool-down. If this happens, the plasma will not remain 'fusion-able'" <a href="https://doi-org.surrey.idm.oclc.org/10.1016/j.jcp.2019.03.020">(Goddijn, 2021)</a>, which would cause disruptions in energy supply and cause significant expenses due to maintenance. Another need to control this is because nuclear fusion has large benefits to energy production, for example "promises to be a safe, low carbon and sustainable part of the world’s future energy supply"<a href="https://www.ukaea.org/fusion-energy/">(UKAEA, n.d.)</a>, which is more beneficial than other forms of energy like fossil fuels which are non-renewables and harmful to the environment. In PIC simulations, a method called parallel processing is used to compute large volumes of data and calculations. Due to this, they require multiple threads of calculations to be ran simultaneously to carry out their required tasks effectively.
</p>

<p>
<strong>Comparing parallel and sequential processing methods: </strong> <br>
Parallel processing is a method in computing that allows multiple streams of data to be processed concurrently, whereas another method called sequential processing "refers to the execution of tasks or instructions in a specific order, where each task is completed before moving on to the next one" <a href="https://www.lenovo.com/gb/en/glossary/sequential-processing/?orgRef=https%253A%252F%252Fwww.google.com%252F&srsltid=AfmBOoqVzpv_Dv8UvCx7v7luNKAPkM7718nQkHIfPzZKHM5AYIrd-Vu_">(Lenovo, 2025)</a>. The reason as to why parallel is used over sequential is that multiple calculations need to be run simultaneously to see real-time results of the simulations, which can be handled much more efficiently by parallel. In table 1 below, the time taken in a simple binary search for one thread of data (sequential) vs figure 2 with 8 threads of data (parallel) are compared to show how each handle different volumes of data.
</p>

	
<p>
  <h4 id="Data table">Data tables</h4>
<body><strong>Table 1: Time taken by sequential processors for searching in recursive version of a binary search</strong></body>
  <table>
    <tr>
      <th>Size of Array</th>
      <th> Time taken for Searching elements in ms (milisecond)</th>
    </tr>
    <tr><td></td><td>First Element</td><td>Mid Element</td><td>Last Element</td></tr>
    <tr><td>100</td><td>1.5</td><td>0.612</td><td>1.37</td></tr>
   	<tr><td>500</td><td>1.527</td><td>1.38</td><td>1.327</td></tr>
	<tr><td>1000</td><td>1.527</td><td>1.381</td><td>1.332</td></tr>
	<tr><td>1500</td><td>1.529</td><td>1.407</td><td>1.384</td></tr>
	<tr><td>2000</td><td>1.619</td><td>1.379</td><td>2.29</td></tr>
	<tr><td>2500</td><td>1.632</td><td>1.415</td><td>1.49</td></tr>
	<tr><td>Average Time</td><td>1.555667</td><td>1.262333</td><td>1.532167</td></tr>
  </table>

<body><strong>Table 2: Time taken in eight threads based (parallel processing) recursive version of a binary search</strong></body>
  <table>
    <tr>
      <th>Size of Array</th>
      <th> Time taken for Searching elements in ms (milisecond)</th>
    </tr>
    <tr><td></td><td>First Element</td><td>Mid Element</td><td>Last Element</td></tr>
    <tr><td>100</td><td>0.90</td><td>0.56</td><td>1.40</td></tr>
   	<tr><td>500</td><td>1.10</td><td>0.59</td><td>1.29</td></td></tr>
	<tr><td>1000</td><td>1.20</td><td>0.59</td><td>1.27</td></tr>
	<tr><td>1500</td><td>1.40</td><td>0.60</td><td>1.35</td></tr>
	<tr><td>2000</td><td>1.20</td><td>6.10</td><td>1.43</td></tr>
	<tr><td>2500</td><td>1.30</td><td>0.65</td><td>1.93</td></tr>
	<tr><td>Average Time</td><td>1.18334</td><td>1.485</td><td>1.445</td></tr>
  </table>
</hr>

In the tables above, it is evident that the 8 thread search is able to handle more data and complete tasks more quickly when comparing the average times taken for both methods. In PIC simulations, the amount of instructions that would  need to be carried out is much greater than this example, therefore parallel processing with multiple threads would be a preferred method to use. However there are some drawbacks of using parallel processing in PIC simulations, for example when "modelling the plasma as cold, the noise is high" <a href="https://ebookcentral.proquest.com/lib/surrey/reader.action?c=UERG&docID=3041636&ppg=133">(Grigoryev et al., 2002)</a>, which is an issue as it means that significant amounts of irrelevant data is produced, which may hide any important underlying patterns that may exist. (may need to find a reference for this). Another drawback is that "the computational requirements can be very high and they drastically increase with increasing plasma density and size of the calculation domain" <a href="https://doi-org.surrey.idm.oclc.org/10.1063/1.5011799">(Wünderlich et al., 2018)</a>, which will cause the computational time taken to increase, which could significantly effect the availability of real time data results. These drawbacks may suggest that parallel processing is not the most suitable method to obtain real-time data, since the time taken must be very minimal to be able to achieve this (add specifics here?). Another disadvantage that can come from parallel processing in general is the limited software compatibility, meaning more money may have to be spent in order to optimise software as well as purchasing specialised hardware. As well as these costs, there are added costs as more powerful parallel systems will have increased power consumption. <br> <br> 
</p>
<p>
<strong>Comparing parallel processing and quantum parallelism methods: </strong> <br>
Instead, a method called quantum parallelism could be used, which is "the capability to execute numerous operations concurrently by exploiting quantum physics" <a href="https://doi-org.surrey.idm.oclc.org/10.1103/PhysRevResearch.7.013177">(Wu et al., 2025)</a>. The reason that this could be used is to utilise quantum technologies "to accelerate simulations or a part of the plasma simulations" <a href="https://doi.org/10.1016/j.future.2025.108087">(Hedge et al., 2025)</a>. This is made possible by the speed at which it is able to compute problems at and the scale of data it can take in, "problems that grow in memory requirements, …can be solved with relatively small quantum computers" <a href="https://www.quera.com/glossary/parallelism">(QuEra, 2021)</a>. However, with these benefits there are also disadvantages relating to hardware limitations. An example of this is cost and complexity, as "super low temperatures are required for the quantum computers to work effectively" <a href="https://www.tencentcloud.com/techpedia/106139">(Tencent Cloud, 2025)</a>, which is expensive to achieve. There are also "limited algorithms that are efficient for quantum parallelism, limiting the applicability of this method"<a href="https://www.tencentcloud.com/techpedia/106139">(Tencent Cloud, 2025)</a>, meaning that some variations of PIC simulations may not be suitable to use quantum parallelism with.
</p>
<p>
To compare costs, a quantum computer, which is required in order to make quantum parallelism work, "will range from $5 million to over $15 million" <a href="https://www.fitdesignldn.com/post/quantum-computer-price-list#:~:text=The%20cost%20of%20manufacturing%20a,monthly%20amounts%20of%20about%20%24100">(Fit Design, 2025)</a>. In comparison, the components for parallel processing will be a lot cheaper altogether, even though multiple components may have to be brought, for example the RTX 4090 graphics card may need to be purchased "starting at £1499" <a href="https://www.nvidia.com/en-gb/geforce/graphics-cards/40-series/rtx-4090/">(NVIDIA, 2025)</a> for one. By comparing the costs, the total for a parallel processing computer will be much lower than that of a quantum computer, and therefore will be a much cheaper and more accessible way to compute the PIC simulations. Alongside hardware expenses, there will be more expenses produced for running these methods, with the quantum computer requiring more power as it is very computationally intensive, which requires more money to run. Quantum parallelism also has much more limited software in comparison to parallel processing, meaning specialised software would be required, resulting in more expenses, whilst also leaving less choice on what can be used meaning there may be more limitations for modelling.
</p>
<p>
<strong>Conclusion:</strong> <br>
Taking into account all the points that have been discussed above, it is evident that parallel processing is the most applicable and cost effective method, that remains one of the most accessible ways to use PIC simulations for the average researcher. It is also able to process large volumes of data at relatively quick speeds, allowing for real-time results to be produced unlike that of sequential processing. Therefore, from this it can be said that parallel processing is especially useful for particle-in-cell simulations.
</p>

</p>
</hr>

<!--Reference table-->
<hr>
<h4 id="References">References</h4>
<p>
<strong>References in Article:</strong> <br>
Dubey, S. and Mathur, K. (2017) 'Comparative Performance Analysis of Binary Search in Sequential and Parallel Processing'. To be published in International journal for Research in Applied Science and Engineering Technology [IJRASET], [Online]. Available at: <a href="https://www.ijraset.com/fileserve.php?FID=10546">https://www.ijraset.com/fileserve.php?FID=10546</a> [Accessed: 15/10/2025]. <br><br>
Fit Design (2025) Complete Quantum Computer Price List | Models, Specs & Costs. Available at:<a href="https://www.fitdesignldn.com/post/quantum-computer-price-list#:~:text=The%20cost%20of%20manufacturing%20a,monthly%20amounts%20of%20about%20%24100">https://www.fitdesignldn.com/post/quantum-computer-price-list#:~:text=The%20cost%20of%20manufacturing%20a,monthly%20amounts%20of%20about%20%24100</a> [Accessed: 16/10/2025]. <br><br>		
Goddijn, M. (2021) Module 3 Plasma Control. Available at:<a href="https://fusenet.eu/sites/default/files/2022-03/Module%203%20-%20Student%20reader%20v.1.0.pdf">https://fusenet.eu/sites/default/files/2022-03/Module%203%20-%20Student%20reader%20v.1.0.pdf</a> [Accessed: 15/10/2025]. <br><br>
Grigoryev, Y. N. et al. (2002) Numerical Particle-in-cell Methods: Theory and Applications. [Online].125-126. Available at: <a href="https://ebookcentral.proquest.com/lib/surrey/reader.action?c=UERG&docID=3041636&ppg=133">https://ebookcentral.proquest.com/lib/surrey/reader.action?c=UERG&docID=3041636&ppg=133</a> [Accessed: 15/10/2025]. <br><br>
Hedge, P. R. et al. (2025) 'A hybrid quantum-classical particle-in-cell method for plasma simulations'. To be published in Future Generation Computer Systems, [Online ahead of print]. Available at: <a href="https://doi.org/10.1016/j.future.2025.108087">https://doi.org/10.1016/j.future.2025.108087</a> [Accessed: 16/10/2025]. <br><br>
Higginson, D. P., et al. (2019) 'A pairwise nuclear fusion algorithm for weighted particle-in-cell plasma simulations'. To be published in Journal of Computational Physics,  [Online]. 439-453. Available at:<a href="https://doi-org.surrey.idm.oclc.org/10.1016/j.jcp.2019.03.020">https://doi-org.surrey.idm.oclc.org/10.1016/j.jcp.2019.03.020</a> [Accessed: 13/10/2025]. <br><br>
Lenovo (2025) What is sequential processing?. Available at:<a href="https://www.lenovo.com/gb/en/glossary/sequential-processing/?orgRef=https%253A%252F%252Fwww.google.com%252F&srsltid=AfmBOoqVzpv_Dv8UvCx7v7luNKAPkM7718nQkHIfPzZKHM5AYIrd-Vu_">https://www.lenovo.com/gb/en/glossary/sequential-processing/?orgRef=https%253A%252F%252Fwww.google.com%252F&srsltid=AfmBOoqVzpv_Dv8UvCx7v7luNKAPkM7718nQkHIfPzZKHM5AYIrd-Vu_</a> [Accessed: 13/10/2025]. <br><br>
NVIDIA (2025) GeForce RTX 4090. Available at: <a href="https://www.nvidia.com/en-gb/geforce/graphics-cards/40-series/rtx-4090/">https://www.nvidia.com/en-gb/geforce/graphics-cards/40-series/rtx-4090/</a> [Accessed: 16/10/2025]. <br><br>
QuEra (2021) Quantum Parallelism. Available at: <a href="https://www.quera.com/glossary/parallelism">https://www.quera.com/glossary/parallelism</a> [Accessed: 16/10/2025]. <br><br>
Tencent Cloud (2025) What are the disadvantages of quantum computing?. Available at:<a href="https://www.tencentcloud.com/techpedia/106139">https://www.tencentcloud.com/techpedia/106139</a> [Accessed: 16/10/2025]. <br><br>
UK Atomic Energy Authority [UKAEA] (no date) Fusion energy. Available at: <a href="https://www.ukaea.org/fusion-energy/">https://www.ukaea.org/fusion-energy/</a> [Accessed: 15/10/2025]. <br><br>
Wu, S. et al. (2025) 'Quantum data parallelism in quantum neural networks' [Online]. Available at: <a href="https://doi-org.surrey.idm.oclc.org/10.1103/PhysRevResearch.7.013177">https://doi-org.surrey.idm.oclc.org/10.1103/PhysRevResearch.7.013177</a> [Accessed: 16/10/2025]. <br><br>
Wünderlich, D. (2018) 'Review of particle-in-cell modelling for the extraction region of large negative hydrogen ion sources for fusion'. [Online]. Available at: <a href="https://doi-org.surrey.idm.oclc.org/10.1063/1.5011799">https://doi-org.surrey.idm.oclc.org/10.1063/1.5011799</a> [Accessed: 14/10/2025]. <br><br>

<strong>References in Video:</strong> <br>
Digital Transformation (2019) 10 criteria to Evaluate when Choosing a New Technology. Available at: <a href="https://verasolutions.org/blog-10-criteria-to-evaluate-when-choosing-a-new-technology/">https://verasolutions.org/blog-10-criteria-to-evaluate-when-choosing-a-new-technology/</a> [Accessed: 26/11/2025].
Dubey, S. and Mathur, K. (2017) 'Comparative Performance Analysis of Binary Search in Sequential and Parallel Processing'. To be published in International journal for Research in Applied Science and Engineering Technology [IJRASET], [Online]. Available at: <a href="https://www.ijraset.com/fileserve.php?FID=10546">https://www.ijraset.com/fileserve.php?FID=10546</a> [Accessed: 15/10/2025]. <br><br>
Bonannella, L. (2022) A guide to Python Multiprocessing and Parallel Programming. Available at: <a href="https://www.sitepoint.com/python-multiprocessing-parallel-programming/>https://www.sitepoint.com/python-multiprocessing-parallel-programming/</a> [Accessed: 26/11/2025]. <br><br>
Figuera, M, R. (2014) Analysis of illumination conditions at the south pole using parallel computing techniques. Available at:<a href="https://www.researchgate.net/figure/Graphical-example-of-sequential-programming-work-flow-A-process-is-not-launched-before_fig12_273675329">https://www.researchgate.net/figure/Graphical-example-of-sequential-programming-work-flow-A-process-is-not-launched-before_fig12_273675329</a> [Accessed: 26/11/2025]. <br><br>
Fiveable (2025) 6.1 Quantum parallelism and interference. Available at: <a href="https://fiveable.me/quantum-computing/unit-6/quantum-parallelism-interference/study-guide/ltIhGfJZ2ARbqCKp"> https://fiveable.me/quantum-computing/unit-6/quantum-parallelism-interference/study-guide/ltIhGfJZ2ARbqCKp</a> [Accessed: 26/11/2025]. <br><br>																									
Sparkes, M. (2022) Korean nuclear fusion reactor achieves 100 million°C for 30 seconds. Available at: <a href="https://www.newscientist.com/article/2336385-korean-nuclear-fusion-reactor-achieves-100-millionc-for-30-seconds/">https://www.newscientist.com/article/2336385-korean-nuclear-fusion-reactor-achieves-100-millionc-for-30-seconds/</a> [Accessed: 26/11/2025]. <br><br>
UKAEA (2022). Inside a Nuclear Fusion Reactor. Available at: <a href="https://www.gov.uk/government/organisations/uk-atomic-energy-authority">https://www.gov.uk/government/organisations/uk-atomic-energy-authority</a> [Accessed: 26/11/2025]. <br><br>
</p>









<hr>
	<h4 id="random">Random stuff</h4>

<p>Using MathXL stuff to give equation: </p>
<!--MathML representations of the quadratic formula-->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<msup><mi>x</mi><mn>2</mn></msup>
<mo>+</mo><mi>4</mi><mo>&InvisibleTimes;</mo><mi>x</mi>
<mo>+</mo><mi>4</mi>
<mo>=</mo>
<mi>0</mi>
  
<!--button colour change-->
  <head>
<title>6929344 Conference project</title>
</head>
<body>
<button id="colorButton">Click me to change colour</button> <br> <br>
<script>
// Get a reference to the button element
var button = document.getElementById("colorButton");
// Function to change the button color
function changeColor() {
// Generate a random color (hexadecimal)
var randomColor = "#" + Math.floor(Math.random()*16777215).toString(16);
// Set the button's background color to the random color
button.style.backgroundColor = randomColor;
}
// Add a click event listener to the button
button.addEventListener("click", changeColor);
</script>
</body>
  
<!--text input box <form target="_blank">
<label for="fname">First name: </label> <br>
<input type="text" id="fname" name="fname" placeholder="Enter text"><br>
<button id="submit">Submit</button>
</form>-->

<!--Input button with function-->
<body>
  <br> <input type="text" id="textInput" placeholder="Enter text"> <br> <br>
  <button id="alertButton">Submit</button> <br>
  <script>
  //reference to input field
  var input = document.getElementById("textInput");
  var button2 = document.getElementById("alertButton");
  //function to show alert with input
  function showAlert() {
    var inputText = input.value;
    alert("You entered: " + inputText);
  }
  button2.addEventListener("click", showAlert);   
  </script>
</body>

  <!--Random number generation and updates-->
  <p id="randomgen">yes</p>
  <button id="changenum">Change</button>
  <script>
    var textchange = document.getElementById("randomgen");
    var button3 = document.getElementById("changenum")
    function onClick() {
      let x = Math.floor((Math.random() * 10) + 1);
      textchange.innerHTML = x;
    }
    button3.addEventListener("click", onClick)
  </script>

</div>

  <!-- //////////////////////////////////////////////////////////////////////////////// -->
  <!-- ////////////////////////////// Adding last update ////////////////////////////// -->
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
    <!-- Last commit time display -->
<div id="last-updated">Loading last update time...</div>
<!-- Verify Button -->
<button onclick="verifyLastUpdatedTime()" style="display: block; margin: 10px auto; padding: 8px 16px;">
    Verify Last Modified Time
</button>
<script>
    async function getLastUpdatedTime() {
        const username = 'FEPSFY6929344';
        const repo = 'FY6929344';
       
        const url = `https://api.github.com/repos/${username}/${repo}/commits`;
        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.github.v3+json',
                }
            });
            if (!response.ok) {
                throw new Error(`Error fetching data: ${response.status} - ${response.statusText}`);
            }
            const commits = await response.json();
            if (commits && commits.length > 0) {
                const lastCommitDate = new Date(commits[0].commit.committer.date);
               
                // Displaying the time on load
                document.getElementById('last-updated').innerText = `Last Modified Time: ${lastCommitDate.toLocaleString()}`;
            } else {
                document.getElementById('last-updated').innerText = 'No commits found in the repository.';
            }
        } catch (error) {
            console.error('Error fetching the last updated time:', error);
            document.getElementById('last-updated').innerText = 'Error fetching update time. Please check the repository details.';
        }
    }
    // Function to verify the last update time by re-fetching it from the API
    async function verifyLastUpdatedTime() {
        document.getElementById('last-updated').innerText = 'Verifying...';
        await getLastUpdatedTime();
        alert("Last modified time has been successfully verified from GitHub API.");
    }
    // Initial load to display the time on page load
    window.onload = getLastUpdatedTime;
</script>


 <!-- //////////////////////////////////////////////////////////////////////////////// -->
  <!-- ////////////////////////////// Word count function ////////////////////////////// -->
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
<!-- Placeholder for total word count -->
<p id="totalWordCount"></p>
<hr>
<script>
   //Function to calculate and display word count for a specified section
   function displayWordCount(sectionId, outputId) {
    // Get the text content from the specified section
    const text = document.getElementById(Analysis).textContent;
    // Split text into words based on spaces and filter out any empty strings
    const wordArray = text.trim().split(/\s+/);
    // Count the words
    const wordCount = wordArray.length;
    // Return the word count for summing purposes
    return wordCount;
  //}
  // Function to calculate and display total word count from selected sections
  function displayTotalWordCount() {
    // Calculate word count for each section and accumulate the total
    const IntroductionCount = displayWordCount("Introduction");
    const AnalysisCount = displayWordCount("Analysis");
    // Calculate the sum of all selected sections
    const totalWordCount = IntroductionCount + AnalysisCount;
    // Display the total word count
    document.getElementById("totalWordCount").innerText = `Total word count: ${totalWordCount}`;
  }
  // Run the function for specific sections and display total count when the page loads
  window.onload = displayTotalWordCount;
	</hr>
</script>
</html>
